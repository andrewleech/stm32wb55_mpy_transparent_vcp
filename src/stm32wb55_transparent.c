#include "py/dynruntime.h"
#include "py/binary.h"
#include "py/objarray.h"
// No need for string.h - we'll use mp_fun_table.memmove_

#include "stm32wb55_local_commands.h"

// QSTRs will be automatically generated by the build system from usage below

// Don't enable this if stdio is used for transp comms.
#define DEBUG_printf(...)  // mp_printf(&mp_plat_print, "rfcore_transp: " __VA_ARGS__)

#define STATE_IDLE 0
#define STATE_NEED_LEN 1
#define STATE_IN_PAYLOAD 2

#define HCI_KIND_BT_CMD (0x01) // <kind=1><?><?><len>
#define HCI_KIND_BT_ACL (0x02) // <kind=2><?><?><len LSB><len MSB>
#define HCI_KIND_BT_EVENT (0x04) // <kind=4><op><len><data...>
#define HCI_KIND_VENDOR_RESPONSE (0x11)
#define HCI_KIND_VENDOR_EVENT (0x12)
#define HCI_KIND_LOCAL_CMD (0x20) // Used by STM32CubeMonitor to query the device
#define HCI_KIND_LOCAL_RSP (0x21)

// Define STATIC macro if not defined
#ifndef STATIC
#define STATIC static
#endif

// Callback python function, can be used to provide feedback on each comm, eg. blink LED.
void mpy_run_callback(mp_obj_t callback, bool on) {
    if (callback != mp_const_none) {
        mp_obj_t args[] = {(on) ? mp_const_true : mp_const_false};
        mp_call_function_n_kw(callback, 1, 0, args);
    }
}


// State structure to maintain between iterations
typedef struct {
    mp_obj_t bluetooth_module;
    mp_obj_t ble_class;
    mp_obj_t ble_instance;
    mp_obj_t hci_cmd_method;
    mp_obj_t time_module;
    mp_obj_t sleep_ms_obj;
    mp_obj_t write_method;
    mp_obj_t read_method;
    uint8_t buf[1024];
    size_t rx;
    size_t len;
    int state;
    int cmd_type;
    bool initialized;
} rfcore_transparent_state_t;

// Global state variable to maintain context between iterations
rfcore_transparent_state_t trans_state;

// The main function - entry point for the native module
STATIC mp_obj_t rfcore_transparent(mp_obj_t stream_in, mp_obj_t stream_out, mp_obj_t callback) {
    // Make sure we have suitable stream objects.
    mp_get_stream_raise(stream_in, MP_STREAM_OP_READ | MP_STREAM_OP_IOCTL);
    mp_get_stream_raise(stream_out, MP_STREAM_OP_WRITE);

    // Initialize the state if first time
    if (!trans_state.initialized) {
        // Import and initialize the Bluetooth module
        trans_state.bluetooth_module = mp_import_name(MP_QSTR_bluetooth, mp_const_none, MP_OBJ_NEW_SMALL_INT(0));
        trans_state.ble_class = mp_import_from(trans_state.bluetooth_module, MP_QSTR_BLE);
        
        // Create an instance of BLE by directly calling its make_new slot
        mp_obj_type_t *ble_type = MP_OBJ_TO_PTR(trans_state.ble_class);
        trans_state.ble_instance = MP_OBJ_TYPE_GET_SLOT(ble_type, make_new)(ble_type, 0, 0, NULL);
        
        // Activate the Bluetooth interface
        mp_obj_t active_method = mp_load_attr(trans_state.ble_instance, MP_QSTR_active);
        mp_obj_t active_args[] = {mp_const_true};
        mp_call_function_n_kw(active_method, 1, 0, active_args);
        
        // Get the hci_cmd method from the instance
        trans_state.hci_cmd_method = mp_load_attr(trans_state.ble_instance, MP_QSTR_hci_cmd);

        trans_state.time_module = mp_import_name(MP_QSTR_time, mp_const_none, MP_OBJ_NEW_SMALL_INT(0));
        trans_state.sleep_ms_obj = mp_import_from(trans_state.time_module, MP_QSTR_sleep_ms);

        // We'll use these functions from MicroPython for streaming
        trans_state.write_method = mp_load_attr(stream_out, MP_QSTR_write);
        trans_state.read_method = mp_load_attr(stream_in, MP_QSTR_read);

        // Initialize the state variables
        trans_state.rx = 0;
        trans_state.len = 0;
        trans_state.state = STATE_IDLE;
        trans_state.cmd_type = 0;
        trans_state.initialized = true;
    }

    // Process a single step of the HCI state machine
    if (trans_state.state == STATE_IN_PAYLOAD && trans_state.len == 0) {
        size_t rsp_len = 0;

        if (trans_state.cmd_type == HCI_KIND_LOCAL_CMD) {
            // Process the command directly (cpu1).
            DEBUG_printf("local_hci_cmd\n");
            rsp_len = local_hci_cmd(trans_state.rx, trans_state.buf);
            DEBUG_printf("rsp: len 0x%x\n", rsp_len);

        } else {
            // Forward command to Bluetooth controller
            DEBUG_printf("bluetooth_ble_hci_cmd\n");
            
            // Extract HCI command information from packet
            // trans_state.buf[0] contains HCI command type (0x01 for BT commands)
            
            // For regular BT commands:
            // OCF is the lower 10 bits of the 16-bit opcode (bytes 1-2)
            // OGF is the upper 6 bits of the 16-bit opcode (bytes 1-2)
            // HCI opcode is little endian, byte 1 is LSB, byte 2 is MSB
            uint16_t opcode = trans_state.buf[1] | (trans_state.buf[2] << 8);
            uint16_t ocf = opcode & 0x03FF;
            uint16_t ogf = (opcode >> 10) & 0x003F;
            
            // Get the parameter length and data
            uint8_t param_len = trans_state.buf[3];
            
            // Create bytes object for request and bytearray for response
            mp_obj_t cmd_data = mp_obj_new_bytes(&trans_state.buf[4], param_len);
            mp_obj_t rsp_data = mp_obj_new_bytearray_by_ref(sizeof(trans_state.buf), trans_state.buf);
            
            // Call the hci_cmd method with the appropriate parameters
            // The method is already bound to the instance, so don't pass self again
            mp_obj_t args[] = {MP_OBJ_NEW_SMALL_INT(ogf), 
                               MP_OBJ_NEW_SMALL_INT(ocf), 
                               cmd_data, 
                               rsp_data};
            
            // Call the method and get the status
            mp_obj_t status_obj = mp_call_function_n_kw(trans_state.hci_cmd_method, 4, 0, args);
            uint8_t status = mp_obj_get_int(status_obj);
            
            // For HCI commands, we need to create a proper HCI response packet
            if (status == 0) {
                // The buffer now contains the raw response data
                // But we need to format it as a proper HCI event packet
                
                // Make space for the HCI event header
                mp_fun_table.memmove_(&trans_state.buf[3], trans_state.buf, param_len); // Move response data
                
                // HCI Event packet format:
                // Byte 0: HCI Event Type (0x04)
                // Byte 1: Command Complete Event Code (0x0E)
                // Byte 2: Parameter Length
                // Byte 3-5: Command Complete Header (num_pkts, cmd_opcode)
                // Byte 6+: Response data
                
                trans_state.buf[0] = 0x04; // Event packet type
                trans_state.buf[1] = 0x0E; // Command Complete event code
                
                // The total length is parameter length + 3 bytes for the Command Complete header
                uint8_t total_len = param_len + 3;
                trans_state.buf[2] = total_len;
                
                // Command Complete header:
                trans_state.buf[3] = 0x01; // Number of command packets allowed
                trans_state.buf[4] = trans_state.buf[1]; // Original opcode LSB
                trans_state.buf[5] = trans_state.buf[2]; // Original opcode MSB
                
                // Status byte (returned by controller)
                trans_state.buf[6] = status;
                
                // Total response length is:
                // 3 bytes HCI event header +
                // 3 bytes Command Complete header +
                // 1 byte status +
                // response data length (minus the status byte already included in 'param_len')
                rsp_len = 7 + (param_len > 0 ? param_len - 1 : 0);
            } else {
                // There was an error, create a simple Command Status packet
                trans_state.buf[0] = 0x04; // Event packet type
                trans_state.buf[1] = 0x0F; // Command Status event code
                trans_state.buf[2] = 0x04; // Parameter length
                trans_state.buf[3] = status; // Status byte
                trans_state.buf[4] = 0x01; // Number of command packets allowed
                trans_state.buf[5] = trans_state.buf[1]; // Original opcode LSB
                trans_state.buf[6] = trans_state.buf[2]; // Original opcode MSB
                rsp_len = 7;
            }
        }

        if (rsp_len > 0) {
            DEBUG_printf("rsp: len 0x%x\n", rsp_len);
            // Create a bytes object and write to stream
            mp_obj_t bytes_obj = mp_obj_new_bytes(trans_state.buf, rsp_len);
            // Use mp_call_function_n_kw instead of mp_call_function_1
            mp_obj_t write_args[] = {bytes_obj};
            mp_call_function_n_kw(trans_state.write_method, 1, 0, write_args);
            mpy_run_callback(callback, false);
        } else {
            DEBUG_printf("rsp: None\n");
        }

        trans_state.rx = 0;
        trans_state.len = 0;
        trans_state.state = STATE_IDLE;

        // Return True indicating a packet was processed
        return mp_const_true;

    } else {
        // Try reading one byte
        mp_obj_t read_args[] = {MP_OBJ_NEW_SMALL_INT(1)};
        mp_obj_t data = mp_call_function_n_kw(trans_state.read_method, 1, 0, read_args);
        
        // Check if we got any data
        // Instead of using mp_obj_is_str_or_bytes, directly check the type
        const mp_obj_type_t *type = mp_obj_get_type(data);
        if ((type == &mp_type_str || type == &mp_type_bytes) && mp_obj_len(data) > 0) {
            // Get the byte
            size_t data_len;
            const byte *data_ptr = (const byte*)mp_obj_str_get_data(data, &data_len);
            if (data_len > 0) {
                uint8_t c = data_ptr[0];
                mpy_run_callback(callback, true);
                
                if (trans_state.state == STATE_IDLE) {
                    if (c == HCI_KIND_BT_CMD || c == HCI_KIND_BT_ACL || c == HCI_KIND_BT_EVENT || 
                        c == HCI_KIND_VENDOR_RESPONSE || c == HCI_KIND_VENDOR_EVENT || c == HCI_KIND_LOCAL_CMD) {
                        trans_state.cmd_type = c;
                        trans_state.state = STATE_NEED_LEN;
                        trans_state.buf[trans_state.rx++] = c;
                        trans_state.len = 0;
                        DEBUG_printf("cmd_type 0x%x\n", c);
                    } else {
                        DEBUG_printf("cmd_type unknown 0x%x\n", c);
                    }
                } else if (trans_state.state == STATE_NEED_LEN) {
                    trans_state.buf[trans_state.rx++] = c;
                    if (trans_state.cmd_type == HCI_KIND_BT_ACL && trans_state.rx == 4) {
                        trans_state.len = c;
                    }
                    if (trans_state.cmd_type == HCI_KIND_BT_ACL && trans_state.rx == 5) {
                        trans_state.len += ((size_t)c) << 8;
                        DEBUG_printf("len 0x%x\n", c);
                        trans_state.state = STATE_IN_PAYLOAD;
                    }
                    if (trans_state.cmd_type == HCI_KIND_BT_EVENT && trans_state.rx == 3) {
                        trans_state.len = c;
                        DEBUG_printf("len 0x%x\n", c);
                        trans_state.state = STATE_IN_PAYLOAD;
                    }
                    if (trans_state.cmd_type == HCI_KIND_BT_CMD && trans_state.rx == 4) {
                        trans_state.len = c;
                        DEBUG_printf("len 0x%x\n", c);
                        trans_state.state = STATE_IN_PAYLOAD;
                    }
                    if (trans_state.cmd_type == HCI_KIND_LOCAL_CMD && trans_state.rx == 4) {
                        trans_state.len = c;
                        DEBUG_printf("len 0x%x\n", c);
                        trans_state.state = STATE_IN_PAYLOAD;
                    }
                } else if (trans_state.state == STATE_IN_PAYLOAD) {
                    trans_state.buf[trans_state.rx++] = c;
                    --trans_state.len;
                }
                
                // Return True if we read data
                return mp_const_true;
            }
        }
    }

    // If we get here, we didn't read anything - return False
    return mp_const_false;
}

MP_DEFINE_CONST_FUN_OBJ_3(rfcore_transparent_obj, rfcore_transparent);

mp_obj_t mpy_init(mp_obj_fun_bc_t *self, size_t n_args, size_t n_kw, mp_obj_t *args) {
    // This must be first, it sets up the globals dict and other things
    MP_DYNRUNTIME_INIT_ENTRY

    // Make the function available in the module's namespace
    mp_store_global(MP_QSTR__rfcore_transparent_start, MP_OBJ_FROM_PTR(&rfcore_transparent_obj));

    // This must be last, it restores the globals dict
    MP_DYNRUNTIME_INIT_EXIT
}