diff --git a/ports/stm32/rfcore.c b/ports/stm32/rfcore.c
index 2d99a3410..76af65210 100644
--- a/ports/stm32/rfcore.c
+++ b/ports/stm32/rfcore.c
@@ -503,7 +503,7 @@ static ssize_t tl_sys_hci_cmd_resp(uint16_t opcode, const uint8_t *buf, size_t l
     return tl_sys_wait_ack(ipcc_membuf_sys_cmd_buf, timeout_ms);
 }
 
-static int tl_ble_wait_resp(void) {
+static size_t tl_ble_wait_resp(parse_hci_info_t *parse) {
     uint32_t t0 = mp_hal_ticks_ms();
     while (!LL_C2_IPCC_IsActiveFlag_CHx(IPCC, IPCC_CH_BLE)) {
         if (mp_hal_ticks_ms() - t0 > BLE_ACK_TIMEOUT_MS) {
@@ -513,8 +513,7 @@ static int tl_ble_wait_resp(void) {
     }
 
     // C2 set IPCC flag -- process the data, clear the flag, and re-enable IRQs.
-    tl_check_msg(&ipcc_mem_ble_evt_queue, IPCC_CH_BLE, NULL);
-    return 0;
+    return tl_check_msg(&ipcc_mem_ble_evt_queue, IPCC_CH_BLE, parse);
 }
 
 // Synchronously send a BLE command.
@@ -522,7 +521,7 @@ static void tl_ble_hci_cmd_resp(uint16_t opcode, const uint8_t *buf, size_t len)
     // Poll for completion rather than wait for IRQ->scheduler.
     LL_C1_IPCC_DisableReceiveChannel(IPCC, IPCC_CH_BLE);
     tl_hci_cmd(ipcc_membuf_ble_cmd_buf, IPCC_CH_BLE, HCI_KIND_BT_CMD, opcode, buf, len);
-    tl_ble_wait_resp();
+    tl_ble_wait_resp(NULL);
 }
 
 /******************************************************************************/
@@ -662,9 +661,16 @@ void rfcore_ble_hci_cmd(size_t len, const uint8_t *src) {
             if (mp_hal_ticks_ms() - timeout_start_ticks_ms > 100) {
                 break;
             }
-            #if MICROPY_PY_BLUETOOTH && MICROPY_BLUETOOTH_NIMBLE
-            mp_bluetooth_nimble_hci_uart_wfi();
+            #if MICROPY_PY_BLUETOOTH_ENABLE_HCI_CMD
+            if (mp_bluetooth_hci_stream_is_active()) {
+                MICROPY_EVENT_POLL_HOOK;
+            } else
             #endif
+            {
+                #if MICROPY_PY_BLUETOOTH && MICROPY_BLUETOOTH_NIMBLE
+                mp_bluetooth_nimble_hci_uart_wfi();
+                #endif
+            }
         }
 
         // Prevent sending another command until this one returns with HCI_EVENT_COMMAND_{COMPLETE,STATUS}.
@@ -797,4 +803,20 @@ static mp_obj_t rfcore_sys_hci(size_t n_args, const mp_obj_t *args) {
 }
 MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(rfcore_sys_hci_obj, 3, 4, rfcore_sys_hci);
 
+size_t rfcore_ble_drain_msg(rfcore_ble_msg_callback_t cb, void *env) {
+    parse_hci_info_t parse = { cb, env, false };
+    // Like rfcore_ble_check_msg but skips BD address auto-configuration.
+    // The host controller manages its own BD address in passthrough mode.
+    return tl_check_msg(&ipcc_mem_ble_evt_queue, IPCC_CH_BLE, &parse);
+}
+
+size_t rfcore_ble_hci_cmd_resp(size_t len, const uint8_t *src,
+                               rfcore_ble_msg_callback_t cb, void *env) {
+    // Disable receive channel, send command, busy-wait for response.
+    LL_C1_IPCC_DisableReceiveChannel(IPCC, IPCC_CH_BLE);
+    rfcore_ble_hci_cmd(len, src);
+    parse_hci_info_t parse = { cb, env, false };
+    return tl_ble_wait_resp(&parse);
+}
+
 #endif // defined(STM32WB)
diff --git a/ports/stm32/rfcore.h b/ports/stm32/rfcore.h
index 39267b325..068ac772e 100644
--- a/ports/stm32/rfcore.h
+++ b/ports/stm32/rfcore.h
@@ -36,6 +36,9 @@ void rfcore_ble_init(void);
 bool rfcore_ble_reset(void);
 void rfcore_ble_hci_cmd(size_t len, const uint8_t *src);
 size_t rfcore_ble_check_msg(rfcore_ble_msg_callback_t cb, void *env);
+size_t rfcore_ble_drain_msg(rfcore_ble_msg_callback_t cb, void *env);
+size_t rfcore_ble_hci_cmd_resp(size_t len, const uint8_t *src,
+                               rfcore_ble_msg_callback_t cb, void *env);
 void rfcore_ble_set_txpower(uint8_t level);
 
 void rfcore_start_flash_erase(void);
